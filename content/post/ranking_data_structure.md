---
title: "排行榜的数据结构和分析"
date: 2020-04-12T14:15:23+08:00
---


> 在大量级的情况下，排行榜利用数据库(redis/mysql等)提供的排序功能比较不好处理，需要手动采用内存排序，排序的数据结构和算法需要谨慎选择，以在节约内存的情况下达到高性能的目的。

> e.g: mysql实时排行，处理单个请求时，百万数据需要2s、千万数据需要1min左右，当存在多个并发请求时效率很难接受。

## 前XXX名排行榜服务(TopN)

特点：

1. 读多写少
2. 全量拉取
3. 一般需要显示的前XXX名比较小，而且是提前定好限制的，比如前100名

方案：

* 显示的排名比较少的情况下（前100、前1000等），可以简单地维护一个集合，在查询的时候逻辑做一遍排序；也可以维护一个有序的数据结构，在每次数据变化时去触发排序。对于大批量的查询请求，可以在不同节点做缓存，设置过期时间来定时拉取数据，查询时只返回缓存中的数据。
* 排名数量级比较大的情况下（10w、百万、亿级别等），需要考虑特定的排序数据结构，比如bst。

## 数据排名服务(“我”的排名)

    问题：有M（M=100万）个人分数在0~N（N=100万）之间，分数变化比较频繁，要求找出分数为X的玩家的排名。

排序数据在实际情况下是离散的、有限的，可以映射到一定的范围内，最简单的是把[X+1,N]的分数段的玩家数量相加，复杂度为O(M)。为了更快地求出某个玩家的排名，可以使用的有桶排序、线段树、统计树等数据结构。如果数据量比较小的话也可以采用redis的zset。

### 桶排序

比如统计学生分数，满分120分，使用两层桶排序，第一层桶从0到119编号：0号桶统计0分的学生人数、1号桶统计1分的学生人数、2号桶统计2分的学生人数...第二层桶从0到19编号，每个桶统计第一层里的6个桶的总人数，比如第二层的0号桶统计第一层的0号桶到5号桶的总人数，第二层的1号桶统计第一层的6号桶到11号桶的总人数...当我们查询65分的人的排名时，如果从第一层开始我们就要从119号桶加到66号桶，但是我们可以先用第二层桶的数据，第二层桶（119-65）/6=9 也就是第二层10~19号桶的数据相加，如果是要求考63分的学生的排名，那除了第二层10~19号桶，还要加上第一层的64~65号桶的数据。如果区间比较大，比如满分是1000分或者10000分，可以考虑多加几层桶来做索引，最后实际形成的是一个树形结构。

### 线段树

具体介绍可以看这里：[OI WIKI 线段树](https://oi-wiki.org/ds/seg/)。其实很简单，二叉搜索树的每个节点的值都是一个固定的数，线段树的每个节点都表示的是一个范围，父节点的范围等于左右子节点的范围连接起来。比如左孩子的是[0, 3],右孩子的是[4, 5], 那么父节点的应该是[0, 5].
线段树的第一个应用场景是连续区间求和。线段树的查询比较简单，如果要查询的范围等于某一个节点的范围，直接返回这个节点的值，如果不等于则需要进行区间结点的拆分，将几个子区间的节点值加起来。但是当数据有更新的时候，不能把所有对应区间的节点都遍历和修改，只能用懒标记，就是把改动存在父节点，之后再查询的时候再把改动下沉到对应的子节点。如果只是更新一个玩家的变化的话比较方便，直接将原来的key-1，新的key+1，需要两次查询修改操作，复杂度O(logN)。

线段树还有一个应用场景是求区间的最值，比如当前有8个网关，每个网关上连接的客户端不同，要求当前连接数最少的客户端。每个节点上需要存储这个节点的区间内连接数最少的网关的id和连接数，然后层层往上比较合并，根节点的是当前最少连接数的网关。当这个网关连接数增加的时候，需要更新对应的最小值，从根节点往下依次更新和比较，主要是一次查询+一次向上更新到根节点，时间和层数有关，复杂度是O(logN)

### 树状数组

具体介绍可以看这里：[OI WIKI 树状数组](https://oi-wiki.org/ds/fenwick/)
比起线段树，树状数组是代码比较简单，但是思路更复杂一点，核心是使用lowbit方法来算出树中每个节点的范围，比如要看88号节点的管理范围：
```
括号后面是进制
88(10)=1011000(2)
lowbit(88) = 8(10) = 1000(2)
所以88号节点管理的范围为8，即80~88
```
树状数组的一个特点是每一层节点是二进制表示中1和0的数量不一样，比如有8个节点，8(10)=1000(2),二进制有4位。它下一层有三个孩子4、6、7，4(10)=100(2),6(10)=110(2),7(10)=111(2),二进制表示都是3位，三个孩子的管理范围不重合，且4的二进制表示中有1个1，6的二进制表示中有2个1，7的二进制表示中有3个1，很有规律，而把这些串起来的方法就是lowbit：
```
1. x-lowbit(x): 同一层节点之间范围井水不犯河水，用x-lowbit(x)把自己的最低位1减掉可以横向跳到同一层相邻的比较小的节点，比如7-lowbit(7)=6, 6-lowbit(6)=4。所以区间求和(1~N)的时候可以用x-lowbit(x)来跳转节点并把节点值都加起来。如果区间不是从1开始的，比如是(M~N)，可以用sum(1~N)-sum(1~M)求得。

2. x+lowbit(x): 孩子节点用x+lowbit(x)等于父节点，所以单点修改的时候可以用x+lowbit(x)从子节点开始不断向上修改父结点的值，加上修改的数据。
```

和线段树比起来，树状数组的代码更简洁，因为需要保存的中间状态更少，因为通过比较巧妙的结构和lowbit进行状态转移。但是也正是因为如此，树状数组这个结构更类似于知识点一样的结构，记得就记得，不记得的话也不好想起来，不像线段树原理比较简单清楚，知道大概的原理就能直接写。而且树状数组本质是维护前缀和，所以它的扩展性是不够的，不能用来处理最大/最小值，因为没有足够的区间信息。

    可以说树状数组能做的事情其实是线段树的一个子集，大多数情况下使用树状数组真的只是因为它好写并且常数小而已。然而zkw线段树(https://zhuanlan.zhihu.com/p/29876526)可以抹掉这个问题，zkw线段树省去了自顶向下查找的过程，而是直接开成满二叉树，所以比N大的最小的2^k就是第一个叶子节点。代码很短也很好理解。

### 统计二叉树

统计二叉树的叶子节点上保存了以当前节点为根的子树的节点总数。插入删除时，只需要把路径上的每个节点保存的节点数量加减1即可。基于这个特性，它可以支持这样的操作：
1. 查找第N大的节点。从根节点开始向下找，当前节点值大于N则在左子树里面找，如果N大于左子树的值，则N减去左子树的值，然后再在右子树中找，等于则就是本节点。
2. 查找某个节点的排名。从该节点往上，如果是右节点就加上左节点的节点值，一直到根节点。

既然是二叉树，为了性能就需要保持树是平衡的，可以考虑各种平衡树的姿势(有的语言自带平衡树的实现，比如cpp里stl的map和set就是红黑树实现的)，在其基础上在节点中加上统计树的特性就可以了。